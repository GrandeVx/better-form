# Custom UI Integration

Guida per integrare better-form con la tua UI library (shadcn/ui, Chakra, Mantine, etc.)

import { Callout } from 'nextra/components'

<Callout type="info">
  better-form e progettato per funzionare sia out-of-the-box che con UI library custom. Puoi sostituire qualsiasi componente mantenendo tutta la logica di validazione e navigazione.
</Callout>

## Livelli di Customizzazione

| Approccio | Use Case | Complessita |
|-----------|----------|-------------|
| **Default Components** | Vuoi usare better-form out-of-the-box | Bassa |
| **Custom Field Components** | Vuoi cambiare solo i campi | Media |
| **Custom Structural Components** | Vuoi cambiare navigation/step indicator | Media |
| **Full Headless** | Vuoi controllo totale su tutta la UI | Alta |

---

## 1. Custom Field Components (shadcn/ui)

Il modo piu comune per integrare la tua UI library e sostituire i field components.

### Pattern "Full Field Component"

Ogni field component include label, input, error e helper text:

```tsx
// components/fields/TextField.tsx
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import type { FieldComponentProps } from '@better_form/core';

export function TextField({
  field,
  value,
  onChange,
  error,
  disabled
}: FieldComponentProps) {
  return (
    <div className="space-y-2">
      {field.label && (
        <Label htmlFor={field.id}>
          {field.label}
          {field.required && <span className="text-destructive ml-1">*</span>}
        </Label>
      )}

      {field.description && (
        <p className="text-sm text-muted-foreground">{field.description}</p>
      )}

      <Input
        id={field.id}
        type={field.inputType || 'text'}
        value={(value as string) || ''}
        onChange={(e) => onChange(e.target.value)}
        placeholder={field.placeholder}
        disabled={disabled}
        className={error ? 'border-destructive' : ''}
      />

      {error && <p className="text-sm text-destructive">{error}</p>}
      {field.helperText && !error && (
        <p className="text-sm text-muted-foreground">{field.helperText}</p>
      )}
    </div>
  );
}
```

### Registrazione Field Components

```tsx
import { WizardProvider } from '@better_form/core';
import { TextField } from '@/components/fields/TextField';
import { SelectField } from '@/components/fields/SelectField';
// ... altri field

const myFieldComponents = {
  text: TextField,
  email: TextField,
  tel: TextField,
  select: SelectField,
  boolean: BooleanField,
  // ... tutti i tipi che usi
};

function MyForm({ config }) {
  return (
    <WizardProvider config={config} fieldComponents={myFieldComponents}>
      {/* Il tuo custom container */}
    </WizardProvider>
  );
}
```

### Esempio SelectField con shadcn/ui

```tsx
// components/fields/SelectField.tsx
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from '@/components/ui/select';
import { Label } from '@/components/ui/label';
import type { FieldComponentProps } from '@better_form/core';

export function SelectField({
  field,
  value,
  onChange,
  error,
  disabled
}: FieldComponentProps) {
  return (
    <div className="space-y-2">
      {field.label && (
        <Label>
          {field.label}
          {field.required && <span className="text-destructive ml-1">*</span>}
        </Label>
      )}

      <Select
        value={value as string}
        onValueChange={onChange}
        disabled={disabled}
      >
        <SelectTrigger className={error ? 'border-destructive' : ''}>
          <SelectValue placeholder={field.placeholder || 'Seleziona...'} />
        </SelectTrigger>
        <SelectContent>
          {field.options?.map((option) => (
            <SelectItem
              key={String(option.value)}
              value={String(option.value)}
              disabled={option.disabled}
            >
              {option.label}
            </SelectItem>
          ))}
        </SelectContent>
      </Select>

      {error && <p className="text-sm text-destructive">{error}</p>}
    </div>
  );
}
```

---

## 2. Full Headless Mode

Per controllo totale, usa solo `WizardProvider` + `useWizard` e costruisci la tua UI.

### Struttura Base

```tsx
import { WizardProvider, useWizard } from '@better_form/core';

// Provider wrapper
function MyForm({ config, fieldComponents }) {
  return (
    <WizardProvider config={config} fieldComponents={fieldComponents}>
      <MyWizardContainer />
    </WizardProvider>
  );
}

// Il tuo container custom
function MyWizardContainer() {
  const {
    // Stato
    currentStep,
    visibleSteps,
    visibleCurrentStepIndex,
    formData,
    errors,
    isSubmitting,
    canProceed,

    // Navigazione
    nextStep,
    previousStep,
    goToStep,
    submit,

    // Field operations
    setFieldValue,
    getVisibleFields,

    // Components
    fieldComponents,
  } = useWizard();

  const visibleFields = getVisibleFields();
  const isFirstStep = visibleCurrentStepIndex === 0;
  const isLastStep = visibleCurrentStepIndex === visibleSteps.length - 1;

  return (
    <div className="my-custom-wizard">
      {/* Step Indicator Custom */}
      <MyStepIndicator
        steps={visibleSteps}
        currentIndex={visibleCurrentStepIndex}
      />

      {/* Step Header */}
      <div className="step-header">
        <h2>{currentStep?.title}</h2>
        {currentStep?.description && <p>{currentStep.description}</p>}
      </div>

      {/* Fields */}
      <div className="fields space-y-6">
        {visibleFields.map((field) => {
          const FieldComponent = fieldComponents[field.type];
          if (!FieldComponent) return null;

          return (
            <FieldComponent
              key={field.id}
              field={field}
              value={formData[field.id]}
              onChange={(val) => setFieldValue(field.id, val)}
              error={errors[field.id]}
              disabled={field.disabled || isSubmitting}
              formData={formData}
            />
          );
        })}
      </div>

      {/* Navigation Custom */}
      <div className="navigation flex justify-between mt-8">
        {!isFirstStep && (
          <Button variant="outline" onClick={previousStep}>
            Indietro
          </Button>
        )}

        <div className="ml-auto">
          {isLastStep ? (
            <Button onClick={submit} disabled={!canProceed || isSubmitting}>
              {isSubmitting ? 'Invio...' : 'Invia'}
            </Button>
          ) : (
            <Button onClick={nextStep} disabled={!canProceed}>
              Avanti
            </Button>
          )}
        </div>
      </div>
    </div>
  );
}
```

---

## 3. Esempio Completo: shadcn/ui Integration

### File Structure

```
components/
├── wizard/
│   ├── WizardContainer.tsx      # Container principale
│   ├── WizardStep.tsx           # Renderer step
│   ├── WizardNavigation.tsx     # Bottoni navigazione
│   ├── WizardStepIndicator.tsx  # Indicatore step
│   └── fields/
│       ├── index.ts             # Export tutti i fields
│       ├── TextField.tsx
│       ├── SelectField.tsx
│       ├── BooleanField.tsx
│       ├── RadioField.tsx
│       └── ...
```

### fields/index.ts

```tsx
// components/wizard/fields/index.ts
import { TextField } from './TextField';
import { SelectField } from './SelectField';
import { BooleanField } from './BooleanField';
import { RadioField } from './RadioField';
import { TextareaField } from './TextareaField';
import { FileUploadField } from './FileUploadField';

export const fieldComponents = {
  text: TextField,
  email: TextField,
  tel: TextField,
  password: TextField,
  url: TextField,
  number: TextField,
  date: TextField,
  select: SelectField,
  multiselect: SelectField,
  boolean: BooleanField,
  checkbox: BooleanField,
  'single-checkbox': BooleanField,
  radio: RadioField,
  textarea: TextareaField,
  file: FileUploadField,
};
```

### Usage

```tsx
import { WizardProvider } from '@better_form/core';
import { WizardContainer } from '@/components/wizard/WizardContainer';
import { fieldComponents } from '@/components/wizard/fields';

function MyPage() {
  const handleSubmit = async (data) => {
    console.log('Form submitted:', data);
    // API call
  };

  return (
    <WizardProvider
      config={myConfig}
      fieldComponents={fieldComponents}
      onSubmit={handleSubmit}
    >
      <WizardContainer />
    </WizardProvider>
  );
}
```

---

## 4. useWizard Hook Reference

L'hook `useWizard` espone tutto lo stato e le azioni del wizard:

```tsx
const {
  // === Configurazione ===
  config,              // WizardConfig originale
  theme,               // Tema corrente
  fieldComponents,     // Registry field components

  // === Stato ===
  state,               // Stato completo (WizardState)
  formData,            // Dati form (alias di state.formData)
  errors,              // Errori validazione
  touched,             // Campi toccati
  isLoading,           // Caricamento in corso
  isSubmitting,        // Submit in corso
  isDirty,             // Form modificato

  // === Step ===
  currentStep,         // Step corrente (WizardStep)
  visibleSteps,        // Array step visibili (con originalIndex)
  visibleCurrentStepIndex,  // Indice step corrente tra i visibili

  // === Navigazione ===
  nextStep,            // () => Promise<boolean> - Vai avanti
  previousStep,        // () => void - Vai indietro
  goToStep,            // (index: number) => void - Vai a step specifico
  submit,              // () => Promise<void> - Invia form

  // === Validazione ===
  canProceed,          // boolean - Puo procedere al passo successivo
  validateField,       // (fieldId: string) => boolean
  validateStep,        // (stepIndex?: number) => boolean

  // === Field Operations ===
  setFieldValue,       // (field: string, value: unknown) => void
  setMultipleValues,   // (values: Record<string, unknown>) => void
  getFieldValue,       // (field: string) => unknown
  getVisibleFields,    // (stepIndex?: number) => WizardField[]
  isFieldVisible,      // (field: WizardField) => boolean
  isFieldDisabled,     // (field: WizardField) => boolean

  // === Blocking Dialog ===
  showBlockingDialog,  // boolean
  setShowBlockingDialog,
  blockingReason,      // string
} = useWizard();
```

---

## 5. FieldComponentProps Reference

Ogni field component riceve queste props:

```typescript
interface FieldComponentProps {
  // Configurazione campo
  field: WizardField;

  // Valore e handlers
  value: unknown;
  onChange: (value: unknown) => void;
  onBlur?: () => void;

  // Stato
  error?: string;
  disabled?: boolean;
  required?: boolean;

  // Contesto
  formData: Record<string, unknown>;
}

// WizardField contiene:
interface WizardField {
  id: string;
  name: string;
  label?: string;
  type: FieldType;
  required?: boolean;
  placeholder?: string;
  description?: string;
  helperText?: string;
  tooltip?: string;
  options?: SelectOption[];
  min?: number;
  max?: number;
  minLength?: number;
  maxLength?: number;
  pattern?: string;
  defaultValue?: unknown;
  width?: FieldWidth;
  transform?: TextTransform;
  suffix?: string;
  prefix?: string;
  // ... e altro
}
```

---

## Tips

### Non importare gli stili default

Se usi UI custom al 100%, non importare `@better_form/core/styles`:

```tsx
// Non necessario se usi full custom
// import '@better_form/core/styles';

// Solo quello che serve
import { WizardProvider, useWizard } from '@better_form/core';
```

### Gestire la visibilita dei campi

I field nascosti (via `showIf`/`hideIf`) non sono inclusi in `getVisibleFields()`. La validazione li salta automaticamente.

```tsx
// getVisibleFields() ritorna solo campi visibili
const visibleFields = getVisibleFields();

// Per controllare un campo specifico
const isVisible = isFieldVisible(field);
const isDisabled = isFieldDisabled(field);
```

### Callbacks onChange

Se il tuo field ha logica `onChange` nel config, better-form la gestisce automaticamente quando chiami `setFieldValue`.

```tsx
// Nel config
{
  name: 'country',
  type: 'select',
  onChange: async (value, formData) => {
    // Questo viene chiamato automaticamente
    const provinces = await fetchProvinces(value);
    return { provinces: provinces };
  }
}

// Nel tuo component - basta chiamare setFieldValue
<SelectField
  onChange={(val) => setFieldValue('country', val)}
/>
// better-form esegue automaticamente la callback del config
```

### Rendering condizionale dei FieldGroup

Puoi anche renderizzare i fieldGroups manualmente:

```tsx
function MyWizardStep() {
  const { currentStep, formData, errors, setFieldValue, fieldComponents } = useWizard();

  return (
    <div>
      {currentStep?.fieldGroups.map((group) => (
        <div key={group.id} className="field-group">
          {group.title && <h3>{group.title}</h3>}

          <div className={group.layout === 'horizontal' ? 'flex gap-4' : 'space-y-4'}>
            {group.fields.map((field) => {
              const FieldComponent = fieldComponents[field.type];
              if (!FieldComponent) return null;

              return (
                <FieldComponent
                  key={field.id}
                  field={field}
                  value={formData[field.id]}
                  onChange={(val) => setFieldValue(field.id, val)}
                  error={errors[field.id]}
                  formData={formData}
                />
              );
            })}
          </div>
        </div>
      ))}
    </div>
  );
}
```
